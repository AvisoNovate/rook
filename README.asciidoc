:imagesdir: images
:api: http://howardlewisship.com/io.aviso/rook/io.aviso.rook.html#var-rook-dispatcher
= Rook

image:http://clojars.org/io.aviso/rook/latest-version.svg[Clojars Project, link="http://clojars.org/io.aviso/rook"]

image:https://drone.io/github.com/AvisoNovate/rook/status.png[Build Status, link="https://drone.io/github.com/AvisoNovate/rook"]

Rook is a set of middleware and handlers to enable metadata-based routing for https://github.com/ring-clojure/ring[Ring] web applications.

The intention is to expose a Clojure _namespace_ as a web service _resource_; there's a default mapping of HTTP verbs
and paths to function names; these can be extended or overridden by metadata on the functions in the namespace.

The end result is that a proper web service resource can be created in very little code.

Rook makes use of its own request routing mechanism that offers very
fast dispatch of requests to handler functions even in the presence of
a very large number of endpoints (what
https://github.com/weavejester/compojure[Compojure] calls routes).
This dispatching mechanism replaces the usual linear search for a
handler capable of producing a non-+nil+ response inside Rook
handlers; however, +nil+ is still returned for requests that cannot be
handled usefully, allowing Rook handlers to interoperate with
Compojure-style handlers. Rook's dispatching mechanism is flexible
enough to be applied in scenarios where the namespace-resource
correspondence does not hold, at the cost of a modest increase of
verbosity in user code.

Rook works well with https://github.com/clojure/core.async[Clojure's core.async] to allow you to build richly interdependent resources
without blocking all your threads.

Rook is available under the terms of the Apache Software License 2.0.

http://howardlewisship.com/io.aviso/rook/[API Documentation]

== Resource Handler Functions

Rook analyzes the public functions of a namespace to determine which functions are invoked and under which circumstances.

The circumstances are a combination of an HTTP verb (GET, POST, etc.)
and the request path. The Rook representation is your choice of
----
[:get "/foo/:id"]   ; :path-spec key in a handler function's metadata
----
or
----
[:get ["foo" :id]]  ; :route-spec key in a handler function's metadata
----
-- these both catch +GET /foo/123+ with +123+ bound to the path parameter +id+.

Rook applies a naming convention to functions, so simply naming a function with a particular name implies a certain
path specification.

.Default Handler Functions
[options="header"]
|===
|Function Name|Verb|Path|Notes

|create
|POST
|/
|Create a new resource

|destroy
|DELETE
|/:id
|Delete existing resource

|edit
|GET
|/:id/edit
|Present HTML form to user to edit existing resource

|index
|GET
|/
|List all existing/matching resources

|new
|GET
|/new
|Present HTML form to user to create new resource

|patch
|PATCH
|/:id
|Modify existing resource; generally implemented as the same as `update`.footnote:[one function can delegate to the other.]

|show
|GET
|/:id
|Retrieve single resource by unique id

|update
|PUT
|/:id
|Modify existing resource

|===

Rook's job is to help with routing the incoming request to your functions;
it also assists with passing information from the request path or query parameters
into your function ... the implementation of the function is entirely yours.

You are free to name your functions as you like; in which case, specify the +:path-spec+ metadata on your functions to inform
Rook:

----
(defn active-users
  "List just users who are currently active."
  {:path-spec [:get "/active"]}     ; equivalently {:route-spec [:get ["active"]]}
  [request]
  ...)
----

The +:path-spec+ contains two values: the keyword for the verb (this may also be the value +:all+) and the path to match.

== Ring Handlers and Middleware

Rook works within the Ring framework by providing middleware and request handlers, forming a processing pipeline.
The section marked *namespace-handler*  in the diagram represents a portion of the overall pipeline constructed by
that function.

Customizing and extending Rook is just a matter of understanding how these middleware and handlers work together, and knowing
how and when to override or inject your own middleware into the pipeline.

== Middleware

Ring is divided into two main pieces: a _middleware_ and a _dispatcher_.

The middleware analyzes the namespace and the incoming request; it will identify the matching resource handler function, storing
the information about it under the +:rook+ request key.

The _dispatcher_ is a Ring request handler that checks for that information; if present it invokes the identified resource handler function.
The resource handler function will return a Ring response.

Applications will often add additional middleware in front of the dispatcher; this allows for other concerns to be addressed,
such as authentication, logging, error handling, etc.

== Argument Resolution

Ring assists with extracting information from the request and provides it as arguments to the invoked resource handler function.

TIP: To avoid confusion, Rook uses the term _parameters_ to refer to route, query and form parameters that are part of an HTTP request; it uses
_arguments_ to refer to function arguments (which are often called parameters, as well).

Ring uses the name of the argument together with metadata attached to
the argument symbol or to the Var holding the handler itself to
identify the value to provide.

If the argument symbol is tagged with +{:header true}+, Rook will
supply the value taken from the header matching the argument name (due
to the way Ring works, the match is case-insensitive; +^:header
content-type+ matches a +Content-Type+ header), and similarly for
+:param+ (non-route request parameters), +:request+ (the entire Ring
request map) and +:request-key+ (a top-level key in the Ring request
map).

Alternatively, if the handler function's metadata includes a
+:resolvers+ key holding a map of argument symbol to argument resolver
function, the resolver specified in the map will be used (the keyword
tags mentioned above can be used in the map as shorthand for the
standard resolvers).

Route parameters are matched by name and should not be tagged.

Arguments that do not match route parameters by name and which do not
have resolvers assigned to them through tags or the +:resolvers+ map
will be resolved at request processing time using a more dynamic
approach.

Dynamic resolution makes use of argument resolvers taken from the
handler function's metadata (at the +:arg-resolvers+ key) and the
namespace's metadata (in absence of +:arg-resolvers+ metadata on the
function); additional argument resolvers can be added by middleware --
+(update-in request [:rook :resolvers] conj ...)+.

It is assumed that standard http://ring-clojure.github.io/ring/ring.middleware.keyword-params.html[Ring middleware] is in place to
convert the +:params+ map from string keys to keyword keys.

Function {api}/io.aviso.rook.html#var-wrap-with-default-arg-resolvers[+wrap-with-default-arg-resolvers+]
provides a default set of argument resolvers:

* Matching value from the +:params+ key of the request, for access to data provided by query parameters and the request body).

* Matching value from the +:route-params+ key of the request, for access to data provided as keywords in the path spec.

* Matching value from the +:headers+ key of the request (with the keyword converted to a string, since +:headers+ keys are
always lower-case strings).

* +:params+ is resolved to the +:params+ map of the Ring request map.

* +:params*+ is resolved to the +:params+ map of the Ring request map, but with the keys _Clojureized_: underscores converted
  to dashes.

* +:request+ is resolved to the Ring request map itself.

* +:resource-uri+ is resolved to the base URI for a resource

For +:resource-uri+, Rook will use information in the Ring request to build a URI that targets a particular
resource namespace; this includes the +:scheme+, +:server-name+, and +:server-port+ keys, plus the
+:context+ key (set by Compojure as part of context routing).

When behind a firewall, the values of the keys may not be valid. Rook will look for a +:server-uri+ request key
and use that in preference to building one from +:scheme+, +:server-name:, and +:server-port+. You can use
middleware to place such a value into the request early in your processing.

Argument resolution can be extended by providing argument resolver functions.  An argument resolver function
is passed the argument keyword, and the Ring request map
and returns the resolved value for the argument.

IMPORTANT: Arguments may be a map, to leverage map destructing. However, you must always provide the +:as+ key
in the map, as that is what Rook will key off of, rather than the argument name as it usually does.

Argument resolvers can fulfill many purposes:

* They can validate inputs from the client.

* They can convert inputs from strings to other types, such as numbers or dates.

* They can provide access to other resources, such as database connection pools.

Argument resolver functions can be specified as metadata directly on the resource handler function;
the +:arg-resolvers+ metadata is a sequence of resolvers.

Function {api}/io.aviso.rook.html#var-wrap-with-arg-resolvers[+wrap-with-arg-resolvers+] is used to specify additional functions for +:arg-resolvers+.
Argument resolvers added later are considered more specific and so are checked first.

Function {api}/io.aviso.rook.html#var-build-map-arg-resolver[+build-map-arg-resolver+] constructs an argument resolver function from a map; It simply returns values from
the map.

Function {api}/io.aviso.rook.html#var-build-fn-arg-resolver[+build-fn-arg-resolver+] constructs an argument resolver function from a map of _functions_; The functions
are selected by the argument keyword, and passed the request.

TIP: Remember that a keyword can act like a function when passed a map, such as the Ring request.

Function {api}/io.aviso.rook.html#var-request-arg-resolver[+request-arg-resolver+] is an argument resolver that resolves the argument keyword against the Ring request map itself.

For example, to allow the argument +conn-pool+ to be resolved as a specific object, and to allow any key from the request map
itself to be resolved, the following function can be defined:

----
(defn add-standard-resolvers
  [handler conn-pool]
  (wrap-with-arg-resolvers handler
                           (build-map-arg-resolver {:conn-pool conn-pool})
                           request-arg-resolver))
----

== Mapping Namespaces

A typical web service will expose some number of resources; under Rook this means mapping a number of namespaces.

The {api}/io.aviso.rook.html#var-namespace-handler[+namespace-handler+] function is the easy way to do this mapping.

----
(namespace-handler
  [["users"] 'org.example.resources.users]
  [["orders"] 'org.example.resources.orders])
----

IMPORTANT: Rook will +require+ the namespace if it has not already been previously loaded into Clojure.

== Writing Rook Middleware

Rook uses the +:rook+ key of the request to store information needed
to process requests. Middleware specified in calls to
+namespace-handler+ can make use of this information.

+:arg-resolvers+::
List of argument resolvers that apply to any invoked resource handler functions.
+:metadata+::
The metadata for the matched function minus the
+:arg-resolvers+ key (as argument resolvers are treated specially by
the dispatch machinery). This is the merged metadata of the function
and the namespace (if there are collisions, the function takes
precedence). This is, notably, where the request schema is found
during request processing (see below).

== Validation

Validation is based on https://github.com/prismatic/schema[Prismatic Schema].

If a function defines +:schema+ metadata, then that is used to validate the request +:params+.
+:params+ contains a merge of query parameters with any data that was submitted in the request body.

Validation assumes that the query parameters keys are converted from strings to keywords (via +ring.middleware.keyword-params+)
and that submitted JSON content is converted to Clojure data using keyword keys (via +rink.middleware.format/wrap.restful-format+).
These filters are part of the standard set of Rook middleware.

Rook performs _coercion_ on the request parameters before validation them and passing them to the next handler. This works
best when you define the explicit types as +s/Str+, +s/Int+, +s/Bool+, and use +s/enum+.

TIP: Use +s/Inst+ to represent time instants (dates that include time).
These will be converted from Strings by parsing an
http://en.wikipedia.org/wiki/ISO8601[ISO-8601] formatted date (+yyyy-mm-ddThh:mm:ss.SSSZ+).footnote:[This format is compatible
with the client-side function +Date.toISOString()+]

You should name your keys for JSON compatibility. By convenience and convention, JSON prefers underscores
rather than embedded dashes.
Rook's argument resolvers allow you to use Clojure naming (embedded dashes) in your resource handler functions.

WARNING: Schema is, by default, picky: any unexpected key is a failure.
Since the Request +:params+ includes arbitrary query parameters, you will usually want to add a mapping of +s/Any+ to +s/Any+ in your
top-level schema, to ensure that spurious query parameters do not cause validation errors.

A sample schema might be:

----
(def index
  {:schema {(s/optional-key :sort_keys)       [(s/enum :first_name :last_name :updated_at)
            (s/optional-key :sort_descending] s/Bool
            (s/optional-key :offset)          s/Int
            (s/optional-key :count)           s/Int
            s/Any                             s/Any}}
  [sort-keys sort-descending offset count]
  ...)
----



If validation is successful, then processing continues with the _coerced_ request +:params+.
In the above example, if the JSON request body was +{"sort_keys":["last_name"]}+, then the +sort-keys+ argument will be
+[:last_name]+.

If validation is unsuccessful, then a 400 Bad Request response is returned; The body of the response contains a map:

----
{
  :error "validation-error"
  :failure "..."
}
----

WARNING: What gets reported as the +:failure+ has yet to be worked out.

== Sample Server

Below is the minimal setup for a standard Jetty Ring server handling Rook resources.

----
(ns org.example.server
  (:use
    compojure.core
  (:require
    [ring.adapter.jetty :as jetty]
    [io.aviso.rook :as rook]
    [io.aviso.rook.schema-validation :as sv])

(defn start-server
   [port]
   (let [handler (rook/namespace-handler
                       {:default-middleware sv/wrap-with-schema-validation}
                       [["users"] 'org.example.resources.users]
                       [["orders"] 'org.example.resources.orders]
                       [["hotels"] 'org.example.resources.hotels]
                       [[:hotel-id "rooms"] 'org.example.resources.rooms]))]
     (jetty/run-jetty handler {:port port :join? false})))
----

A more complete example would also configure https://github.com/AvisoNovate/twixt[Twixt] for exception reporting, and to (perhaps) provide a client-side application
that uses the provided web service.

== Async

Rook can be used entirely as a normal set of Ring response handlers and middleware.  However, it is even more useful when combined
with https://github.com/clojure/core.async[Clojure's core.async library].

Rook includes support for an asynchronous pipeline, where processing of a request can occur without blocking any threads
(and parts of which may occur in parallel).
Async Rook also supports re-entrant requests that bypass the protocol layers; this allows your resource handler functions
to easily send _loopback_ requests to other resources within the same server, without needing to encode and decode data, or send HTTP/HTTPs
requests, or block threads.
This will ensure that your code _eats its own dog food_ by using the same REST APIs it exports, rather than bypassing
the APIs to invoke Clojure functions directly.

Finally, Rook includes a client library that makes it very easy to initiate loopback requests and process failure and success responses,
again built on top of core.async.

Time will tell just how well this works (its early days yet), but we hope to be able to handle a very large volume of requests
very efficiently.

In addition, by leveraging Jetty's support for continuations, it is easy to create a server that is fully asynchronous end to end: a very small number of request processing threads in Jetty can handle a very large number of concurrent requests, with nearly all the real work taking place in threads managed by +go+ or +thread+ blocks.

More documentation on this is forthcoming.

WARNING: When returning a response whose body is an InputStream, it is important to set the +Content-Length+
header to the size of the stream.
Failure to do so results in spurious 404 responses to the client.footnote:[It is not clear whether this is a bug in
Jetty, or related to how Rook's async support uses Jetty continuations.]

